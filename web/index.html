<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SUPARNA - 3D Mission Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0e17;
      color: #ddd;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }

    #canvas {
      display: block;
    }

    #panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 260px;
      height: 100vh;
      background: rgba(12, 16, 24, 0.92);
      border-left: 1px solid #1e2a3a;
      padding: 24px 18px;
      z-index: 10;
      backdrop-filter: blur(12px);
      overflow-y: auto;
    }

    #panel h1 {
      font-size: 22px;
      color: #00d4ff;
      margin-bottom: 4px;
      letter-spacing: 2px;
    }

    #panel .sub {
      font-size: 11px;
      color: #556;
      margin-bottom: 20px;
    }

    .stat {
      margin-bottom: 14px;
    }

    .stat label {
      font-size: 11px;
      color: #667;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat .val {
      font-size: 20px;
      font-weight: 700;
      color: #eee;
    }

    .stat .val.accent {
      color: #00d4ff;
    }

    .stat .val.green {
      color: #1db954;
    }

    .stat .val.warn {
      color: #f0a030;
    }

    .bar-wrap {
      width: 100%;
      height: 10px;
      background: #1a1f2e;
      border-radius: 5px;
      margin-top: 4px;
    }

    .bar-fill {
      height: 100%;
      border-radius: 5px;
      transition: width 0.3s;
    }

    .bar-fill.green {
      background: linear-gradient(90deg, #1db954, #1ed760);
    }

    .bar-fill.cyan {
      background: linear-gradient(90deg, #0090b0, #00d4ff);
    }

    .bar-fill.warn {
      background: linear-gradient(90deg, #c09030, #f0c040);
    }

    .bar-fill.danger {
      background: linear-gradient(90deg, #c03030, #e04040);
    }

    .divider {
      border: none;
      border-top: 1px solid #1e2a3a;
      margin: 16px 0;
    }

    .checklist {
      list-style: none;
      padding: 0;
    }

    .checklist li {
      font-size: 13px;
      padding: 3px 0;
      color: #556;
    }

    .checklist li.done {
      color: #1db954;
    }

    .checklist li.active {
      color: #00d4ff;
      font-weight: 600;
    }

    .controls {
      margin-top: 16px;
    }

    .btn {
      display: inline-block;
      padding: 6px 14px;
      margin: 3px;
      background: #1a1f2e;
      border: 1px solid #2a3040;
      border-radius: 6px;
      color: #aab;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #252b3a;
      border-color: #00d4ff;
      color: #fff;
    }

    .btn.active {
      background: #00d4ff22;
      border-color: #00d4ff;
      color: #00d4ff;
    }

    .algo-tag {
      display: inline-block;
      font-size: 10px;
      padding: 2px 8px;
      margin: 2px;
      border-radius: 10px;
      border: 1px solid;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0e17;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      flex-direction: column;
    }

    #loading h2 {
      color: #00d4ff;
      font-size: 28px;
      margin-bottom: 10px;
    }

    #loading p {
      color: #556;
      font-size: 14px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #1a1f2e;
      border-top: 3px solid #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="loading">
    <div class="spinner"></div>
    <h2>SUPARNA</h2>
    <p>Loading mission data...</p>
  </div>
  <div id="panel">
    <h1>SUPARNA</h1>
    <div class="sub">3D Mission Visualizer</div>
    <div class="stat"><label>Status</label>
      <div class="val accent" id="status">PLANNING</div>
    </div>
    <div class="stat">
      <label>Coverage</label>
      <div class="val green" id="coverage">0.0%</div>
      <div class="bar-wrap">
        <div class="bar-fill cyan" id="covBar" style="width:0%"></div>
      </div>
    </div>
    <div class="stat">
      <label>Battery</label>
      <div class="val" id="battery">100%</div>
      <div class="bar-wrap">
        <div class="bar-fill green" id="batBar" style="width:100%"></div>
      </div>
    </div>
    <hr class="divider">
    <div class="stat"><label>Loiters</label>
      <div class="val" id="loiterCount">0 / 0</div>
    </div>
    <div class="stat"><label>Distance</label>
      <div class="val" id="distance">0 m</div>
    </div>
    <div class="stat"><label>Speed</label>
      <div class="val" id="speedDisp">2.0x</div>
    </div>
    <hr class="divider">
    <label style="font-size:11px;color:#667;text-transform:uppercase;letter-spacing:1px">Mission</label>
    <ul class="checklist" id="checklist"></ul>
    <hr class="divider">
    <label style="font-size:11px;color:#667;text-transform:uppercase;letter-spacing:1px">Algorithms</label>
    <div style="margin-top:6px">
      <span class="algo-tag" style="border-color:#1db954;color:#1db954">Greedy Set Cover</span>
      <span class="algo-tag" style="border-color:#00d4ff;color:#00d4ff">Dubins Curves</span>
      <span class="algo-tag" style="border-color:#f0c040;color:#f0c040">A* Search</span>
      <span class="algo-tag" style="border-color:#e04040;color:#e04040">Bug2 Avoidance</span>
      <span class="algo-tag" style="border-color:#c080ff;color:#c080ff">TSP Heuristic</span>
    </div>
    <hr class="divider">
    <div class="controls">
      <div class="btn" id="btnPlay" onclick="togglePause()">&#9208; Pause</div>
      <div class="btn" onclick="changeSpeed(-0.5)">- Slow</div>
      <div class="btn" onclick="changeSpeed(0.5)">+ Fast</div>
      <div class="btn" onclick="resetMission()">&#8635; Reset</div>
      <div class="btn" onclick="newMission()">&#10227; New Map</div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // === Globals ===
    let scene, camera, renderer, controls;
    let missionData = null;
    let droneMesh, trailLine, trailPoints = [];
    let loiterMeshes = [], obstacleMeshes = [], coverageMeshes = [];
    let groundPlane, gridHelper;

    let simTime = 0, speed = 2.0, paused = false;
    let wpIdx = 0, state = 'FLY';
    let pos = { x: 0, y: 0 }, heading = 0;
    let loiterCenter = null, loiterAngle = 0, loiterRevs = 0, loiterR = 60;
    let nLoitersDone = 0, distance = 0, battery = 100;
    let coveredSet = new Set();
    let safeWaypoints = [];
    const SPD = 35, TURN_RATE = 2.5;

    // === Init ===
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0e17);
      scene.fog = new THREE.Fog(0x0a0e17, 800, 1800);
      camera = new THREE.PerspectiveCamera(50, (window.innerWidth - 260) / window.innerHeight, 1, 5000);
      camera.position.set(500, 800, 600);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth - 260, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.insertBefore(renderer.domElement, document.getElementById('panel'));
      renderer.domElement.id = 'canvas';
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(500, 0, 350);
      controls.enableDamping = true; controls.dampingFactor = 0.08;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.minDistance = 200; controls.maxDistance = 2000;
      controls.update();
      scene.add(new THREE.AmbientLight(0x334466, 0.6));
      var dl = new THREE.DirectionalLight(0xffffff, 0.8);
      dl.position.set(400, 600, 300); dl.castShadow = true;
      dl.shadow.camera.near = 1; dl.shadow.camera.far = 2000;
      dl.shadow.camera.left = -600; dl.shadow.camera.right = 600;
      dl.shadow.camera.top = 600; dl.shadow.camera.bottom = -600;
      dl.shadow.mapSize.set(2048, 2048);
      scene.add(dl);
      scene.add(new THREE.HemisphereLight(0x003355, 0x0a0e17, 0.3));
      window.addEventListener('resize', function () {
        camera.aspect = (window.innerWidth - 260) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - 260, window.innerHeight);
      });
    }

    // === Build Scene ===
    function buildScene(data) {
      [].concat(loiterMeshes, obstacleMeshes, coverageMeshes).forEach(function (m) { scene.remove(m); });
      if (groundPlane) scene.remove(groundPlane);
      if (gridHelper) scene.remove(gridHelper);
      if (droneMesh) scene.remove(droneMesh);
      if (trailLine) scene.remove(trailLine);
      loiterMeshes = []; obstacleMeshes = []; coverageMeshes = [];
      var W = data.map.width, H = data.map.height;

      // Ground
      groundPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(W, H),
        new THREE.MeshStandardMaterial({ color: 0x161a24, roughness: 0.9 })
      );
      groundPlane.rotation.x = -Math.PI / 2; groundPlane.position.set(W / 2, -0.5, H / 2);
      groundPlane.receiveShadow = true; scene.add(groundPlane);

      gridHelper = new THREE.GridHelper(Math.max(W, H), 40, 0x1a2030, 0x141820);
      gridHelper.position.set(W / 2, 0, H / 2); scene.add(gridHelper);

      // Obstacles
      data.obstacles.forEach(function (obs) {
        var h = obs.is_no_fly ? 15 : 30 + obs.radius * 0.3;
        var clr = obs.is_no_fly ? 0x802020 : 0x8b3030;
        var mesh = new THREE.Mesh(
          new THREE.CylinderGeometry(obs.radius, obs.radius * 1.1, h, 24),
          new THREE.MeshStandardMaterial({ color: clr, roughness: 0.6, metalness: 0.2, transparent: true, opacity: 0.85 })
        );
        mesh.position.set(obs.x, h / 2, obs.y); mesh.castShadow = true;
        scene.add(mesh); obstacleMeshes.push(mesh);

        var ring = new THREE.Mesh(
          new THREE.RingGeometry(obs.radius + 18, obs.radius + 22, 32),
          new THREE.MeshBasicMaterial({ color: 0x401515, side: THREE.DoubleSide, transparent: true, opacity: 0.4 })
        );
        ring.rotation.x = -Math.PI / 2; ring.position.set(obs.x, 1, obs.y);
        scene.add(ring); obstacleMeshes.push(ring);
      });

      // Loiter targets
      data.loiters.forEach(function (l) {
        var torus = new THREE.Mesh(
          new THREE.TorusGeometry(l.radius, 1.5, 8, 48),
          new THREE.MeshBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.5 })
        );
        torus.rotation.x = -Math.PI / 2; torus.position.set(l.x, 15, l.y);
        scene.add(torus); loiterMeshes.push(torus);

        var vl = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(l.x, 0, l.y), new THREE.Vector3(l.x, 15, l.y)]),
          new THREE.LineBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.3 })
        );
        scene.add(vl); loiterMeshes.push(vl);
      });

      // Home marker
      var hm = new THREE.Mesh(
        new THREE.ConeGeometry(8, 20, 6),
        new THREE.MeshStandardMaterial({ color: 0x1db954, emissive: 0x0a5020 })
      );
      hm.position.set(data.home.x, 10, data.home.y);
      scene.add(hm); obstacleMeshes.push(hm);

      // Drone
      var dg = new THREE.Group();
      var body = new THREE.Mesh(
        new THREE.ConeGeometry(6, 18, 4),
        new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x004466, metalness: 0.5, roughness: 0.3 })
      );
      body.rotation.z = Math.PI / 2; body.rotation.y = Math.PI / 2; dg.add(body);
      var glow = new THREE.Mesh(
        new THREE.RingGeometry(10, 14, 20),
        new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
      );
      glow.rotation.x = -Math.PI / 2; dg.add(glow);
      droneMesh = dg;
      droneMesh.position.set(data.home.x, 15, data.home.y);
      scene.add(droneMesh);

      // Trail
      trailLine = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0x00a0c0, transparent: true, opacity: 0.6 })
      );
      scene.add(trailLine);

      // Path preview
      var pts = safeWaypoints.map(function (w) { return new THREE.Vector3(w.x, 12, w.y); });
      var pl = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineDashedMaterial({ color: 0x2a4060, dashSize: 10, gapSize: 10, transparent: true, opacity: 0.4 })
      );
      pl.computeLineDistances(); scene.add(pl); obstacleMeshes.push(pl);

      controls.target.set(W / 2, 0, H / 2);
      camera.position.set(W / 2, Math.max(W, H) * 0.9, H / 2 + Math.max(W, H) * 0.5);
      controls.update();
    }

    // === Pre-compute safe paths around obstacles ===
    function ptInObs(px, py) {
      if (!missionData) return false;
      for (var i = 0; i < missionData.obstacles.length; i++) {
        var obs = missionData.obstacles[i];
        var dx = px - obs.x, dy = py - obs.y;
        if (Math.sqrt(dx * dx + dy * dy) < obs.radius + 35) return true;
      }
      return false;
    }

    function lineHitsObs(x1, y1, x2, y2) {
      if (!missionData) return null;
      for (var i = 0; i < missionData.obstacles.length; i++) {
        var obs = missionData.obstacles[i];
        var margin = obs.radius + 40;
        var dx = x2 - x1, dy = y2 - y1, len2 = dx * dx + dy * dy;
        if (len2 < 1) continue;
        var t = ((obs.x - x1) * dx + (obs.y - y1) * dy) / len2;
        t = Math.max(0, Math.min(1, t));
        var px = x1 + t * dx, py = y1 + t * dy;
        var dist = Math.sqrt((obs.x - px) * (obs.x - px) + (obs.y - py) * (obs.y - py));
        if (dist < margin) return obs;
      }
      return null;
    }

    function computeSafePath() {
      if (!missionData) return;
      var raw = missionData.waypoints;
      safeWaypoints = [];

      for (var i = 0; i < raw.length; i++) {
        safeWaypoints.push(raw[i]);
        if (i < raw.length - 1) {
          // Insert detour waypoints if straight path hits obstacles
          for (var attempt = 0; attempt < 6; attempt++) {
            var last = safeWaypoints[safeWaypoints.length - 1];
            var obs = lineHitsObs(last.x, last.y, raw[i + 1].x, raw[i + 1].y);
            if (!obs) break;

            // Perpendicular detour around the obstacle
            var dx = raw[i + 1].x - last.x, dy = raw[i + 1].y - last.y;
            var len = Math.sqrt(dx * dx + dy * dy) || 1;
            var px = -dy / len, py = dx / len;
            var detourR = obs.radius + 55;

            // Try both perpendicular sides
            var d1x = obs.x + px * detourR, d1y = obs.y + py * detourR;
            var d2x = obs.x - px * detourR, d2y = obs.y - py * detourR;

            var detour;
            if (!ptInObs(d1x, d1y)) {
              detour = { x: d1x, y: d1y, type: 'detour' };
            } else if (!ptInObs(d2x, d2y)) {
              detour = { x: d2x, y: d2y, type: 'detour' };
            } else {
              detour = { x: obs.x + px * (detourR + 50), y: obs.y + py * (detourR + 50), type: 'detour' };
            }
            safeWaypoints.push(detour);
          }
        }
      }
    }

    // === Simulation ===
    function normalizeAngle(a) {
      while (a > Math.PI) a -= 2 * Math.PI;
      while (a < -Math.PI) a += 2 * Math.PI;
      return a;
    }

    function updateSim(dt) {
      if (paused || state === 'DONE' || !missionData) return;

      if (state === 'LOITER') {
        if (!loiterCenter) { state = 'FLY'; return; }
        var w = SPD / loiterR;
        loiterAngle += w * dt;
        loiterRevs += w * dt / (2 * Math.PI);
        pos.x = loiterCenter.x + loiterR * Math.cos(loiterAngle);
        pos.y = loiterCenter.y + loiterR * Math.sin(loiterAngle);
        heading = normalizeAngle(loiterAngle + Math.PI / 2);
        distance += SPD * dt;
        battery -= 0.05 * dt;
        markCoverage(loiterCenter.x, loiterCenter.y, loiterR + 20);
        if (loiterRevs >= 1.0) {
          nLoitersDone++;
          state = 'FLY';
          loiterCenter = null;
          wpIdx++;
        }
        updateDroneMesh();
        return;
      }

      if (wpIdx >= safeWaypoints.length) { state = 'DONE'; return; }

      var target = safeWaypoints[wpIdx];
      var distToTarget = Math.sqrt((target.x - pos.x) * (target.x - pos.x) + (target.y - pos.y) * (target.y - pos.y));
      var th = Math.atan2(target.y - pos.y, target.x - pos.x);

      // Smooth turning â€” path is pre-cleared of obstacles
      var err = normalizeAngle(th - heading);
      var mt = TURN_RATE * dt;
      if (Math.abs(err) > mt) heading += err > 0 ? mt : -mt;
      else heading = th;
      heading = normalizeAngle(heading);

      // Move forward
      var d = SPD * dt;
      pos.x += d * Math.cos(heading);
      pos.y += d * Math.sin(heading);
      distance += d;
      battery -= 0.08 * dt;

      markCoverage(pos.x, pos.y, 50);

      // Check waypoint reached
      var captureR = (target.type === 'return' || target.type === 'home') ? 40 : 20;
      if (distToTarget < captureR) {
        if (target.type === 'loiter') {
          state = 'LOITER';
          loiterCenter = { x: target.x, y: target.y };
          loiterAngle = heading - Math.PI / 2;
          loiterRevs = 0;
          loiterR = target.radius || 60;
        } else {
          wpIdx++;
        }
      }
      updateDroneMesh();
    }

    function markCoverage(cx, cy, radius) {
      var res = missionData.map.resolution || 10;
      var gcx = Math.floor(cx / res), gcy = Math.floor(cy / res);
      var rc = Math.ceil(radius / res);
      for (var dx = -rc; dx <= rc; dx++) {
        for (var dy = -rc; dy <= rc; dy++) {
          if (dx * dx + dy * dy > rc * rc) continue;
          var nx = gcx + dx, ny = gcy + dy;
          var key = nx + ',' + ny;
          if (coveredSet.has(key)) continue;
          var wx = nx * res, wy = ny * res;
          if (wx < 0 || wx >= missionData.map.width || wy < 0 || wy >= missionData.map.height) continue;
          if (ptInObs(wx, wy)) continue;
          coveredSet.add(key);
          var tile = new THREE.Mesh(
            new THREE.PlaneGeometry(res, res),
            new THREE.MeshBasicMaterial({ color: 0x1db954, transparent: true, opacity: 0.35, side: THREE.DoubleSide })
          );
          tile.rotation.x = -Math.PI / 2;
          tile.position.set(wx + res / 2, 0.5, wy + res / 2);
          scene.add(tile); coverageMeshes.push(tile);
        }
      }
    }

    function updateDroneMesh() {
      if (!droneMesh) return;
      droneMesh.position.set(pos.x, 15 + Math.sin(simTime * 3) * 2, pos.y);
      droneMesh.rotation.y = -heading + Math.PI / 2;
      trailPoints.push(new THREE.Vector3(pos.x, 14, pos.y));
      if (trailPoints.length > 2000) trailPoints.shift();
      if (trailLine && trailPoints.length > 1) {
        trailLine.geometry.dispose();
        trailLine.geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
      }
    }

    // === UI ===
    function updateUI() {
      if (!missionData) return;
      var totalLoiters = missionData.loiters.length;
      var W = missionData.map.width, H = missionData.map.height;
      var res = missionData.map.resolution || 10;
      var totalCells = Math.floor(W / res) * Math.floor(H / res);
      var covPct = Math.min(100, (coveredSet.size / totalCells) * 100);

      document.getElementById('status').textContent =
        state === 'DONE' ? 'MISSION COMPLETE' :
          state === 'LOITER' ? 'LOITERING (' + (nLoitersDone + 1) + '/' + totalLoiters + ')' :
            wpIdx >= safeWaypoints.length - 1 ? 'RETURNING HOME' :
              'EN ROUTE > L' + (nLoitersDone + 1);
      document.getElementById('status').className =
        'val ' + (state === 'DONE' ? 'green' : state === 'LOITER' ? 'warn' : 'accent');

      document.getElementById('coverage').textContent = covPct.toFixed(1) + '%';
      document.getElementById('covBar').style.width = covPct + '%';
      var bat = Math.max(0, battery);
      document.getElementById('battery').textContent = bat.toFixed(0) + '%';
      document.getElementById('batBar').style.width = bat + '%';
      document.getElementById('batBar').className = 'bar-fill ' + (bat < 20 ? 'danger' : bat < 40 ? 'warn' : 'green');
      document.getElementById('loiterCount').textContent = nLoitersDone + ' / ' + totalLoiters;
      document.getElementById('distance').textContent = distance.toFixed(0) + ' m';
      document.getElementById('speedDisp').textContent = speed.toFixed(1) + 'x';

      var cl = document.getElementById('checklist'); cl.innerHTML = '';
      for (var i = 0; i < totalLoiters; i++) {
        var li = document.createElement('li');
        var done = i < nLoitersDone, active = i === nLoitersDone && state === 'LOITER';
        li.className = done ? 'done' : active ? 'active' : '';
        li.textContent = (done ? '> ' : active ? '>> ' : '  ') + 'Loiter ' + (i + 1);
        cl.appendChild(li);
      }
      var retLi = document.createElement('li');
      retLi.className = state === 'DONE' ? 'done' : '';
      retLi.textContent = (state === 'DONE' ? '> ' : '  ') + 'Return HOME';
      cl.appendChild(retLi);

      missionData.loiters.forEach(function (l, i) {
        var mesh = loiterMeshes[i * 2];
        if (!mesh) return;
        if (i < nLoitersDone) { mesh.material.color.set(0x1db954); mesh.material.opacity = 0.7; }
        else if (i === nLoitersDone && state === 'LOITER') { mesh.material.color.set(0x00d4ff); mesh.material.opacity = 0.8; }
      });
    }

    // === Controls ===
    function togglePause() {
      paused = !paused;
      document.getElementById('btnPlay').textContent = paused ? 'Play' : 'Pause';
      document.getElementById('btnPlay').className = paused ? 'btn active' : 'btn';
    }
    function changeSpeed(delta) { speed = Math.max(0.5, Math.min(10, speed + delta)); }
    function resetMission() {
      if (!missionData) return;
      wpIdx = 0; state = 'FLY'; nLoitersDone = 0;
      distance = 0; battery = 100;
      pos = { x: missionData.home.x, y: missionData.home.y };
      heading = 0; trailPoints = [];
      coveredSet.clear();
      coverageMeshes.forEach(function (m) { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
      coverageMeshes = [];
      loiterMeshes.forEach(function (m, i) {
        if (i % 2 === 0 && m.material) { m.material.color.set(0xffb040); m.material.opacity = 0.5; }
      });
      computeSafePath();
    }
    function newMission() {
      document.getElementById('loading').style.display = 'flex';
      document.getElementById('loading').querySelector('p').textContent = 'Run: python export_mission.py then refresh';
      setTimeout(function () { location.reload(); }, 3000);
    }

    // === Loop ===
    function animate() {
      requestAnimationFrame(animate);
      var dt = 1 / 60; simTime += dt;
      for (var i = 0; i < Math.ceil(speed * 2); i++) updateSim(dt * 0.5);
      controls.update(); updateUI();
      renderer.render(scene, camera);
    }

    // === Start ===
    async function start() {
      init();
      try {
        var resp = await fetch('mission.json');
        missionData = await resp.json();
      } catch (e) {
        document.getElementById('loading').querySelector('p').textContent = 'Run: python export_mission.py first!';
        return;
      }
      pos = { x: missionData.home.x, y: missionData.home.y };
      computeSafePath();
      buildScene(missionData);
      document.getElementById('loading').style.display = 'none';
      animate();
    }
    start();
  </script>
</body>

</html>